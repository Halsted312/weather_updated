# Open-Maker Strategy Planning Document

**Created:** 2025-11-27 02:05:12
**Status:** IMPLEMENTED
**Last Updated:** 2025-11-27 02:20:00

---

## Executive Summary

Create a new modular "open-maker fixed price" backtest strategy for Kalshi weather markets. The strategy:
- Posts maker limit orders at market open (10am ET on `event_date - 1`)
- Uses Visual Crossing forecast to pick a bracket
- Assumes fill at fixed price P (e.g., 40c or 50c)
- Holds to settlement with maker fees ($0 for weather markets)
- Includes Optuna tuning with train/test split
- Includes WebSocket listener for live market open detection

---

## Design Decisions

### 1. Architecture: Option B - Self-Contained Package

**Decision:** Create a completely self-contained `open_maker/` package with no direct imports from `backtest/midnight_heuristic.py`.

**Rationale:**
- Changes to midnight_heuristic cannot silently break open_maker
- Each strategy can evolve independently
- Easier to reason about and test in isolation
- If duplication becomes painful later, factor shared pieces into `core/` module

**Structure:**
```
open_maker/
    __init__.py
    core.py                 # Main backtest logic
    optuna_tuner.py         # Hyperparameter optimization
    market_open_listener.py # WebSocket listener for live mode
    utils.py                # Self-contained helpers (bracket selection, fees, etc.)
```

### 2. Forecast Timing

**Decision:** Use previous-day forecast (`lead_days=1`) by default, with `basis_offset_days` tunable.

**Logic:**
- Market for Nov 28 opens at 10am ET on Nov 27
- At that moment, use Nov 27's forecast for Nov 28's high
- In database terms: `target_date = event_date`, `basis_date = event_date - 1`

**Query:**
```sql
SELECT tempmax_fcst_f, basis_date
FROM wx.forecast_snapshot
WHERE city = :city
  AND target_date = :event_date
  AND basis_date <= :listing_local_date
ORDER BY basis_date DESC
LIMIT 1;
```

### 3. WebSocket Listener

**Decision:** Implement a real, working listener now, but keep it read-only/logging for this step.

**Behavior:**
- Connect to `wss://api.elections.kalshi.com/trade-api/ws/v2` with RSA-PSS auth
- Subscribe to `market_lifecycle_v2` for weather series
- On `data.state == "open"`, log series_ticker, event_ticker, market_ticker, timestamp
- Store records in `sim.market_open_log` table
- Do NOT place orders (yet)

### 4. Persistence

**Decision:** Save all trades and runs to the database (not just console output).

**Tables to use:**
- `sim.trade` - Individual trade records
- `sim.run` - Backtest run metadata and aggregate metrics

---

## Market Open Timing (Reference)

From Kalshi documentation and market pages:

| Event | Time |
|-------|------|
| Market Open | 10:00am ET on `event_date - 1` |
| Last Trading | 11:59pm **local time** on `event_date` |
| Settlement | After midnight observation |

**Database field:** `kalshi.markets.listed_at` (UTC) is the authoritative open timestamp.

**WebSocket Channel:** `market_lifecycle_v2` - subscribe by series ticker (e.g., `KXHIGHCHI`).

---

## File Specifications

### File 1: `open_maker/__init__.py`

Simple package initialization:

```python
"""
Open-Maker Strategy Package

A self-contained backtest strategy for posting maker limit orders
at market open and holding to settlement.
"""

from .core import run_backtest, OpenMakerTrade, OpenMakerResult, OpenMakerParams
```

---

### File 2: `open_maker/utils.py`

Self-contained utilities (copied/adapted from midnight_heuristic):

**Functions to include:**

1. **`kalshi_maker_fee(num_contracts: int, price: float) -> float`**
   - Returns 0.0 for weather markets (no maker fees)
   - Formula for markets with fees: `ceil(0.0175 * C * P * (1-P))`

2. **`kalshi_taker_fee(num_contracts: int, price: float) -> float`**
   - Formula: `ceil(0.07 * C * P * (1-P))`
   - Not used in open_maker, but included for completeness

3. **`find_bracket_for_temp(markets_df, event_date, temp) -> Tuple[ticker, floor, cap]`**
   - Priority: between > less/less_or_equal > greater/greater_or_equal
   - Adapted from midnight_heuristic but self-contained

4. **`get_city_timezone(city: str) -> ZoneInfo`**
   - Map city to timezone (e.g., "chicago" -> "America/Chicago")

**Implementation notes:**
- Use pandas DataFrames for market data (consistent with existing code)
- All strike comparisons handle NULL floor_strike/cap_strike correctly

---

### File 3: `open_maker/core.py`

Main backtest module.

**Dataclasses:**

```python
@dataclass
class OpenMakerParams:
    entry_price: float = 0.50        # Fixed entry price (0.30-0.60)
    temp_bias_deg: float = 0.0       # Adjust forecast before bracket selection
    basis_offset_days: int = 1       # 1 = previous day forecast, 0 = same day
    bet_amount_usd: float = 200.0    # Bet size per trade

@dataclass
class OpenMakerTrade:
    city: str
    event_date: date
    ticker: str
    forecast_basis_date: date
    temp_fcst_open: float           # Raw forecast temp
    temp_adjusted: float            # After bias adjustment
    floor_strike: Optional[float]
    cap_strike: Optional[float]
    entry_price: float              # Cents
    num_contracts: int
    amount_usd: float               # Total position cost
    tmax_final: float               # Actual settlement temp
    bin_won: bool
    pnl_gross: float
    fees: float
    pnl_net: float

@dataclass
class OpenMakerResult:
    trades: List[OpenMakerTrade]
    params: OpenMakerParams
    start_date: date
    end_date: date
    cities: List[str]
    strategy_id: str = "open_maker_v1"

    # Computed properties
    @property
    def total_pnl(self) -> float: ...
    @property
    def win_rate(self) -> float: ...
    @property
    def num_trades(self) -> int: ...

    def summary(self) -> Dict[str, Any]: ...
```

**Core functions:**

```python
def load_forecast_data(session, cities: List[str], start_date: date, end_date: date) -> pd.DataFrame:
    """Load forecast snapshots for the date range."""

def load_settlement_data(session, cities: List[str], start_date: date, end_date: date) -> pd.DataFrame:
    """Load settlement data (tmax_final)."""

def load_market_data(session, cities: List[str], start_date: date, end_date: date) -> pd.DataFrame:
    """Load market data with listed_at timestamps."""

def get_forecast_at_open(
    forecast_df: pd.DataFrame,
    city: str,
    event_date: date,
    listed_at: datetime,
    basis_offset_days: int = 1
) -> Optional[float]:
    """
    Get forecast high for event_date using forecast available at market open.

    Default: Use basis_date = event_date - basis_offset_days
    """

def run_backtest(
    cities: List[str],
    start_date: date,
    end_date: date,
    params: OpenMakerParams,
    strategy_name: str = "open_maker_v1",
) -> OpenMakerResult:
    """
    Run the open-maker backtest.

    For each (city, event_date):
    1. Get market listed_at timestamp
    2. Get forecast at open (with basis_offset_days)
    3. Apply temp_bias_deg adjustment
    4. Find bracket for adjusted temp
    5. Calculate position size at entry_price
    6. Determine P&L based on settlement
    """

def save_results_to_db(result: OpenMakerResult) -> None:
    """Save trades to sim.trade and run summary to sim.run."""

def print_results(result: OpenMakerResult) -> None:
    """Print backtest results to console."""

def print_debug_trades(result: OpenMakerResult, n: int = 20) -> None:
    """Print detailed info for N random trades for sanity checking."""
```

**CLI:**

```bash
python -m open_maker.core \
  --all-cities \
  --days 365 \
  --price 0.50 \
  --bias 0.0 \
  --bet-amount 200 \
  [--start-date YYYY-MM-DD --end-date YYYY-MM-DD] \
  [--save] \
  [--debug]
```

---

### File 4: `open_maker/optuna_tuner.py`

Hyperparameter optimization with train/test split.

**Search Space:**

```python
entry_price     = trial.suggest_categorical("entry_price", [0.30, 0.35, 0.40, 0.45, 0.50, 0.55])
temp_bias_deg   = trial.suggest_float("temp_bias_deg", -3.0, 3.0)
basis_offset_days = trial.suggest_int("basis_offset_days", 0, 1)  # 0=same day, 1=previous day
```

**Train/Test Split:**
- Default: 70% train, 30% test (chronological)
- Optimize on train period
- Report final metrics on test period (out-of-sample)

**CLI:**

```bash
python -m open_maker.optuna_tuner \
  --all-cities \
  --days 365 \
  --trials 50 \
  --metric total_pnl \
  --train-ratio 0.7 \
  [--storage sqlite:///optuna_open_maker.db] \
  [--study-name open_maker_v1]
```

**Output:**
- Best parameters from train period
- Test period performance with best params
- Train period performance with best params (for comparison)
- Parameter importance analysis

---

### File 5: `open_maker/market_open_listener.py`

WebSocket listener for live market open detection.

**Implementation:**

```python
import asyncio
import json
import websockets
from datetime import datetime, timezone
from sqlalchemy import insert
from src.kalshi.client import KalshiClient
from src.db import get_db_session
from src.db.models import MarketOpenLog  # New table

WEATHER_SERIES = [
    "KXHIGHCHI",  # Chicago
    "KXHIGHAUS",  # Austin
    "KXHIGHLA",   # Los Angeles
    "KXHIGHMIA",  # Miami
    "KXHIGHDEN",  # Denver
    "KXHIGHNYE",  # NYC
    "KXHIGHPHI",  # Philadelphia
]

WS_URL = "wss://api.elections.kalshi.com/trade-api/ws/v2"

class MarketOpenListener:
    def __init__(self, api_key: str, private_key_path: str):
        self.api_key = api_key
        self.private_key_path = private_key_path
        self.client = KalshiClient(api_key, private_key_path)

    def _generate_ws_auth_headers(self) -> dict:
        """Generate auth headers for WebSocket connection."""
        # Same RSA-PSS signature as REST API
        ...

    async def connect_and_listen(self):
        """Main WebSocket connection loop."""
        headers = self._generate_ws_auth_headers()

        async with websockets.connect(WS_URL, extra_headers=headers) as ws:
            # Subscribe to market_lifecycle_v2 for all weather series
            for series in WEATHER_SERIES:
                sub_msg = {
                    "cmd": "subscribe",
                    "channels": [{
                        "name": "market_lifecycle_v2",
                        "params": {"series_ticker": series}
                    }]
                }
                await ws.send(json.dumps(sub_msg))

            # Listen for messages
            async for raw in ws:
                await self._handle_message(json.loads(raw))

    async def _handle_message(self, msg: dict):
        """Process incoming WebSocket message."""
        if msg.get("channel") != "market_lifecycle_v2":
            return

        data = msg.get("data", {})
        state = data.get("state")

        if state == "open":
            await self._log_market_open(data)

    async def _log_market_open(self, data: dict):
        """Log market open event to database."""
        record = {
            "series_ticker": data.get("series_ticker"),
            "event_ticker": data.get("event_ticker"),
            "market_ticker": data.get("market_ticker"),
            "opened_at": datetime.now(timezone.utc),
            "raw_data": json.dumps(data),
        }

        with get_db_session() as session:
            session.execute(insert(MarketOpenLog).values(**record))
            session.commit()

        print(f"[OPEN] {record['market_ticker']} at {record['opened_at']}")

async def main():
    settings = get_settings()
    listener = MarketOpenListener(
        api_key=settings.kalshi_api_key,
        private_key_path=settings.kalshi_private_key_path,
    )
    await listener.connect_and_listen()

if __name__ == "__main__":
    asyncio.run(main())
```

---

## Database Schema Additions

### Table: `sim.market_open_log`

```sql
CREATE TABLE sim.market_open_log (
    id SERIAL PRIMARY KEY,
    series_ticker VARCHAR(20) NOT NULL,
    event_ticker VARCHAR(50) NOT NULL,
    market_ticker VARCHAR(50) NOT NULL,
    opened_at TIMESTAMPTZ NOT NULL,
    raw_data JSONB,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

CREATE INDEX idx_market_open_log_event ON sim.market_open_log(event_ticker);
CREATE INDEX idx_market_open_log_opened_at ON sim.market_open_log(opened_at);
```

### Updates to `sim.trade`

Add columns if not present:
- `forecast_basis_date DATE` - Basis date of forecast used
- `temp_fcst_open REAL` - Raw forecast temperature at open

---

## P&L Calculation Logic

For each trade:

```python
# Position sizing
cost_per_contract = entry_price / 100  # Convert cents to dollars
num_contracts = int(bet_amount_usd / cost_per_contract)
actual_cost = num_contracts * cost_per_contract

# Settlement
if bin_won:
    pnl_gross = num_contracts * (1.0 - entry_price / 100)  # Win $1 - cost per contract
else:
    pnl_gross = -num_contracts * (entry_price / 100)  # Lose cost per contract

# Fees (maker = $0 for weather markets)
fees = kalshi_maker_fee(num_contracts, entry_price / 100)  # Returns 0.0

# Net P&L
pnl_net = pnl_gross - fees
```

**Example:**
- Entry price: 50c
- Bet amount: $200
- Contracts: 400 (= $200 / $0.50)
- If WIN: pnl_gross = 400 * $0.50 = $200, pnl_net = $200
- If LOSE: pnl_gross = -400 * $0.50 = -$200, pnl_net = -$200

---

## Implementation Order

| Step | Task | Priority | Status |
|------|------|----------|--------|
| 1 | Create `open_maker/utils.py` with bracket selection, fees | HIGH | DONE |
| 2 | Create `open_maker/core.py` with dataclasses and backtest logic | HIGH | DONE |
| 3 | Add CLI and `print_results` function | HIGH | DONE |
| 4 | Test backtest with fixed params (price=0.50) | HIGH | DONE |
| 5 | Create `open_maker/optuna_tuner.py` | MEDIUM | DONE |
| 6 | Run Optuna optimization | MEDIUM | DONE |
| 7 | Create `sim.market_open_log` table | MEDIUM | DONE |
| 8 | Create `open_maker/market_open_listener.py` | MEDIUM | DONE |
| 9 | Test WebSocket listener | MEDIUM | PENDING |
| 10 | Wire listener to live trading (future) | LOW | FUTURE |

---

## Testing Checklist

### Backtest Validation
- [x] Run backtest on 90 days of data for Chicago only (79 trades, 69.6% win rate, +$6200 P&L)
- [x] Verify trade count matches expected (79 trades for 90 days - some days missing data)
- [x] Check sample trades with `--debug` flag (verified bracket matching works correctly)
- [x] Verify P&L calculations are correct (entry * contracts when lose, (1-entry) * contracts when win)
- [ ] Compare win rate at different entry prices (40c vs 50c vs 60c)

### Optuna Validation
- [x] Run 10 trials on Chicago (tested with 90 days, 70% train split)
- [x] Verify train/test split is chronological (train: Aug 28 - Oct 29, test: Oct 30 - Nov 26)
- [x] Check that test performance is reported separately (test P&L shown separately)
- [x] Verify best params are reasonable (entry=35c, bias=2.2F, offset=1)

### WebSocket Validation
- [ ] Listener connects successfully
- [ ] Auth headers work (no 401 errors)
- [ ] Market open events are logged to database
- [ ] Events map correctly to (city, event_date)

---

## Actual Results (All Cities, 90 Days, price=50c)

```
============================================================
OPEN-MAKER BACKTEST RESULTS
============================================================

Strategy: open_maker_v1
Run ID: 083b8330
Period: 2025-08-28 to 2025-11-26
Cities: chicago, austin, denver, los_angeles, miami, philadelphia

Parameters:
  Entry Price: 50.0c
  Temp Bias: +0.0F
  Basis Offset: 1 day(s)
  Bet Amount: $200.00

Results:
  Total Trades: 461
  Win Rate: 63.8%
  Total P&L: $+25,400.00
  Avg P&L/Trade: $+55.10
  Total Wagered: $92,200.00
  ROI: +27.55%

By City:
  austin         :   82 trades, 54.9% win, $+1,600.00 P&L
  chicago        :   79 trades, 69.6% win, $+6,200.00 P&L
  denver         :   64 trades, 70.3% win, $+5,200.00 P&L
  los_angeles    :   65 trades, 61.5% win, $+3,000.00 P&L
  miami          :   89 trades, 57.3% win, $+2,600.00 P&L
  philadelphia   :   82 trades, 70.7% win, $+6,800.00 P&L
============================================================
```

**Note:** These results assume 100% fill rate at the fixed entry price.
Real-world results will depend on actual market liquidity and spreads.

---

## Expected Outputs

After running the backtest:

```
============================================================
BACKTEST RESULTS
============================================================
Strategy: open_maker_v1
Period: 2024-11-27 to 2025-11-26 (365 days)
Cities: chicago, austin, los_angeles, miami, denver, nyc, philadelphia

Total Trades: 2,555
Win Rate: 45.2%
Total P&L: $1,234.56
Avg P&L per Trade: $0.48
P&L per Day: $3.38

By City:
  chicago:     412 trades, 46.1% win, $198.45
  austin:      365 trades, 44.7% win, $156.23
  los_angeles: 365 trades, 47.4% win, $234.12
  ...
============================================================
```

---

## Risk Notes

1. **Fill Assumption:** This backtest assumes all maker orders eventually fill. In reality, some orders may not fill if the market moves away. A more realistic model would check if historical prices reached the entry price.

2. **Market Impact:** With larger sizes, our orders could move the market. Start with small live sizes ($10-20 per trade).

3. **Forecast Quality:** Strategy performance depends heavily on forecast accuracy. Monitor for seasonal degradation.

4. **Data Coverage:** Ensure candle data exists for the backtest period. Run coverage check:
   ```sql
   SELECT city, COUNT(DISTINCT event_date) as days
   FROM kalshi.markets
   WHERE event_date >= '2024-01-01'
   GROUP BY city;
   ```

---

## Next Steps After Implementation

1. Run backtest with default params (price=0.50, bias=0.0, offset=1)
2. Compare results at different fixed prices
3. Run Optuna to find optimal params
4. Analyze test set performance for overfitting
5. Start WebSocket listener in background
6. Once validated, wire to live trading with small size ($10/trade)

---

## Part 7: Sharpe Metrics Enhancement

**Status:** COMPLETED (2025-11-27)

Added risk-adjusted performance metrics to `OpenMakerResult`:

### New Properties

```python
@property
def pnl_std_per_trade(self) -> float:
    """Standard deviation of per-trade P&L."""

@property
def sharpe_per_trade(self) -> float:
    """Per-trade Sharpe: mean(pnl) / stdev(pnl)."""

@property
def daily_pnl_series(self) -> Dict[date, float]:
    """Aggregate P&L by event_date across all cities."""

@property
def sharpe_daily(self) -> float:
    """Daily aggregate Sharpe: mean(daily_pnl) / stdev(daily_pnl)."""

@property
def pnl_std_daily(self) -> float:
    """Standard deviation of daily aggregate P&L."""
```

### Interpretation

- **Per-trade Sharpe**: Good for comparing parameter sets in Optuna optimization
- **Daily Sharpe**: Closer to "what does my P&L time-series look like as a daily strategy?"

### Updated CLI Output

```
Results:
  Total Trades: 461 (89 days)
  Win Rate: 63.8%
  Total P&L: $+25,400.00
  ...

Risk Metrics:
  P&L Std (per-trade): $200.00
  Sharpe (per-trade): 0.276
  P&L Std (daily): $453.21
  Sharpe (daily): 0.629
```

---

## Part 8: Exit Heuristic (NEXT PHASE)

**Status:** PLANNED

### Overview

Add early exit logic to reduce losses when the market signals the distribution has shifted away from our chosen bracket.

### Exit Rule Design

**Which brackets to watch:**
- Treat brackets as ordered by strike (lowest to highest)
- If my chosen bracket has index `i`, watch:
  - `i - 2` (two brackets lower)
  - `i + 2` (two brackets higher)
- Only if indices are in `[0, n-1]`

**Idea:** If a far bin (two brackets away) reprices significantly richer than mine, the market is signaling the distribution has shifted.

**Which price to compare:**
- Primary: YES bid price (`yes_bid_c`) - what we can actually hit to exit
- Fallback 1: `mid = (yes_bid_c + yes_ask_c) / 2` if both exist
- Fallback 2: `close_c` as last resort

### Rule Shape

```python
# After grace period, before cutoff:
if (
    t >= entry_time + exit_after_minutes and
    t <= entry_time + exit_latest_minutes
):
    # Check if far bracket repriced significantly
    if bid_far(t) >= bid_mine(t) + edge_cents:
        # Exit position at our bid price
        exit_trade(ticker, our_bid_price)
```

### Tunable Parameters

| Parameter | Description | Search Range |
|-----------|-------------|--------------|
| `edge_cents` | Price threshold to trigger exit | 3-10 cents |
| `exit_after_minutes` | Grace period after entry | 30-120 min |
| `exit_latest_minutes` | Latest time to exit | 240-480 min |
| `exit_distance` | Brackets away to watch | 1 or 2 |

### Implementation Steps

1. Add `exit_*` parameters to `OpenMakerParams`
2. Load candle data for the trading day
3. For each trade, track far-bracket prices
4. Implement exit check logic in backtest loop
5. Add exit P&L calculation (sold at bid vs held to settlement)
6. Update Optuna tuner with exit parameters
7. Run optimization with train/test split

### Required Data

Need minute-level candle data (`kalshi.candles_1m`) for:
- YES bid prices
- YES ask prices
- Close prices

---

## References

- Kalshi API Docs: https://trading-api.readme.io/
- WebSocket Lifecycle Channel: `market_lifecycle_v2`
- Existing code: `backtest/midnight_heuristic.py`, `scripts/kalshi_ws_recorder.py`
- Kalshi fee schedule: Maker = $0 for weather, Taker = 0.07 * C * P * (1-P)
